from datetime import date
from pathlib import Path

import pytest
from dateutil.relativedelta import relativedelta
from django.core import mail
from django.test import override_settings
from pytest_bdd import scenarios
from pytest_mock import MockerFixture

from mcod.datasets.tasks import (
    create_csv_metadata_files,
    create_xml_metadata_files,
    send_dataset_update_reminder,
)

scenarios("features/dataset_send_update_reminder.feature")


class TestDatasetUpdateReminder:
    @override_settings(EMAIL_BACKEND="django.core.mail.backends.locmem.EmailBackend")
    @pytest.mark.parametrize(
        "update_freq, date_delay, reldelta",
        [
            ("weekly", 1, relativedelta(days=7)),
            ("monthly", 3, relativedelta(months=1)),
            ("quarterly", 7, relativedelta(months=3)),
            ("everyHalfYear", 7, relativedelta(months=6)),
            ("yearly", 7, relativedelta(years=1)),
        ],
    )
    def test_update_reminder_is_sent(
        self, update_freq, date_delay, reldelta, dataset_with_resource, admin
    ):
        ds = dataset_with_resource
        ds.title = "Test wysyłki notyfikacji dot. aktualizacji zbioru"
        ds.update_frequency = update_freq
        ds.modified_by = admin
        ds.save()
        first_res = ds.resources.all()[0]
        first_res.data_date = date.today() + relativedelta(days=date_delay) - reldelta
        first_res.type = "file"
        first_res.save()
        send_dataset_update_reminder()
        assert len(mail.outbox) == 1
        assert (
            mail.outbox[0].subject
            == "Test wysyłki notyfikacji dot. aktualizacji zbioru"
        )
        assert "Przypomnienie o aktualizacji Zbioru danych" in mail.outbox[0].body
        assert mail.outbox[0].to == [admin.email]

    @override_settings(EMAIL_BACKEND="django.core.mail.backends.locmem.EmailBackend")
    @pytest.mark.parametrize(
        "res_type, update_freq, date_delay, reldelta, notification_enabled",
        [
            ("api", "weekly", 1, relativedelta(days=7), True),
            ("website", "monthly", 3, relativedelta(months=1), True),
            ("file", "monthly", 3, relativedelta(months=1), False),
            ("file", "notApplicable", 3, relativedelta(months=1), True),
            ("file", "daily", 3, relativedelta(months=1), True),
        ],
    )
    def test_update_reminder_is_not_sent(
        self,
        res_type,
        update_freq,
        date_delay,
        reldelta,
        notification_enabled,
        dataset_with_resource,
        admin,
    ):
        ds = dataset_with_resource
        ds.update_frequency = update_freq
        ds.modified_by = admin
        ds.is_update_notification_enabled = notification_enabled
        ds.save()
        first_res = ds.resources.all()[0]
        first_res.data_date = date.today() + relativedelta(days=date_delay) - reldelta
        first_res.type = res_type
        first_res.save()
        send_dataset_update_reminder()
        assert len(mail.outbox) == 0

    @override_settings(EMAIL_BACKEND="django.core.mail.backends.locmem.EmailBackend")
    def test_update_reminder_sent_to_notification_recipient_if_set(
        self, dataset_with_resource, admin
    ):
        ds = dataset_with_resource
        ds.title = "Test wysyłki notyfikacji dot. aktualizacji zbioru"
        ds.update_frequency = "weekly"
        ds.modified_by = admin
        ds.update_notification_recipient_email = "test-recipient@test.com"
        ds.save()
        first_res = ds.resources.all()[0]
        first_res.data_date = (
            date.today() + relativedelta(days=1) - relativedelta(days=7)
        )
        first_res.type = "file"
        first_res.save()
        send_dataset_update_reminder()
        assert len(mail.outbox) == 1
        assert (
            mail.outbox[0].subject
            == "Test wysyłki notyfikacji dot. aktualizacji zbioru"
        )
        assert mail.outbox[0].to == ["test-recipient@test.com"]
        assert mail.outbox[0].to != [admin.email]


class TestMetadataFileCreation:
    """
    Tests metadata file creation functionalities.

    Contains test methods for validating the creation of various types of metadata files
    and their proper handling under different conditions.

    The class includes tests for:
    - Creating XML and CSV metadata files.
    - Validating metadata file creation with previous file deletion.
    """

    @pytest.mark.parametrize(
        "extension, task",
        [
            ("xml", create_xml_metadata_files),
            ("csv", create_csv_metadata_files),
        ],
    )
    @pytest.mark.usefixtures("tmp_path", "mocker")
    def test_create_metadata_files(
        self, tmp_path: str, mocker: "MockerFixture", extension, task
    ):
        """
        Tests the creation of XML metadata files.

        Validates the creation of XML metadata files by executing a specified task and
        verifying the existence of a file in 'tmp_path' with a specific naming format.

        Args:
        - tmp_path (str): Temporary directory provided for testing.
        - mocker (MockerFixture): Pytest mocker fixture for mocking objects.
        - extension (str): Expected extension of the metadata file.
        - task (callable): The task generating the metadata file.
        """
        with override_settings(METADATA_MEDIA_ROOT=tmp_path):
            # Create a mock for datetime.
            # Ensure that test will not fail due to datetime.today().date()
            new_today = self.mock_date(year=2023, month=12, day=24, mocker=mocker)

            task()
            file = Path(f"{tmp_path}") / f"pl/katalog_{new_today}.{extension}"
            assert file.is_file()

    @staticmethod
    def mock_date(mocker: "MockerFixture", year: int, month: int, day: int) -> date:
        """
        Mocks the current date with a specified year, month, and day.
        Returns:
        - new_today (datetime.date): The newly created date object with specified values.
        """
        new_today = date(year=year, month=month, day=day)
        datetime_mock = mocker.Mock()
        datetime_mock.today.return_value.date.return_value = new_today
        mocker.patch("mcod.datasets.tasks.datetime", datetime_mock)

        return new_today

    @pytest.mark.parametrize(
        "extension, task",
        [
            ("xml", create_xml_metadata_files),
            ("csv", create_csv_metadata_files),
        ],
    )
    @pytest.mark.usefixtures("tmp_path", "mocker")
    def test_create_metadata_files_with_deletion_previous(
        self, tmp_path, mocker, task, extension
    ):
        """
        Tests metadata file creation with previous file deletion.

        Validates the creation of metadata files while simulating file deletion
        and recreation. It ensures the proper creation and deletion of files
        based on the specified conditions.
        """
        with override_settings(METADATA_MEDIA_ROOT=tmp_path):
            new_today = self.mock_date(year=2023, month=12, day=24, mocker=mocker)
            task()
            file = Path(f"{tmp_path}") / f"pl/katalog_{new_today}.{extension}"

            new_today2 = self.mock_date(year=2023, month=12, day=25, mocker=mocker)
            task()
            file2 = Path(f"{tmp_path}") / f"pl/katalog_{new_today2}.{extension}"

            assert not file.is_file()
            assert file2.is_file()
